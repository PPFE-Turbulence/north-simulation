#
# NORTH input file
#
# x - The radial coordinate (rho)
# y - The height of the cylinder (z)
# z - The azimuthal coordinate (theta)

timestep 	= 10 		# Output timestep
nout 		= 8 		# Number of output steps

myg 		= 0			# No need for Y communications
mxg 		= 1 		# x-guard cells

monitor_timestep = true

# Set the z coordinate range
ZMIN = 0.0
ZMAX = 1.0 

[mesh]
nx 			= 256+2*mxg	# internal grid points plus guard cells along x-axis
ny 			= 1 		# y is along magnetic field, set to 1
nz 			= 256 		# internal grid points along z-axis

Lx 			= north:R/north:rho_s 		# simulation length along x-axis
Lz 			= north:R/north:rho_s 		# simulation length along z-axis

dx 			= Lx/(nx-1-2*mxg)           # grid spacing along x-axis
dy 			= 1.0                       # grid spacing along y-axis
dz 			= Lz/(nz-1)                 # grid spacing along z-axis

# The metrics
xl          = (x * Lx)                  # x (rho)-coordinate in range [0,Lx]
g33         = 1/(xl^2)                  # contravariant metric tensor component g^{33} (g^{theta theta})
J           = xl                        # Jacobian (determinant)

# Puts the boundaries half a step outside the last gridpoints
symmetricGlobalY=true
symmetricGlobalX=true

# Position of the separatrix
# Points 0 <= x < ixseps1 are inside separatrix, ixseps1 <= x < ngx outside
# --------Non-periodic----------
ixseps1 = -1
ixseps2 = -1
# ------------------------------

[mesh:ddx] 	# methods used for x derivative terms
first  		= C4  		# d/dx (f)
second 		= C4  		# d^2/dx^2 (f)
upwind 		= W3  		# v_x d/dx (f)
flux   		= U1  		# d/dx (v_x f)

[mesh:ddy] 	# methods used for y derivative terms
first  		= C4 		# d/dx (f)
second 		= C4 		# d^2/dx^2 (f)
upwind 		= W3 		# v_x d/dx (f)
flux   		= U1 		# d/dx (v_x f)

[mesh:ddz] 	# methods used for z derivative terms
first  		= C4  		# d/dx (f)
second 		= C4  		# d^2/dx^2 (f)
upwind 		= W3  		# v_x d/dx (f)
flux   		= U1  		# d/dx (v_x f)

[laplace]
flags = 0   # Flags for Laplacian inversion

[solver]
type 		= pvode

[north]
R 		= 0.250     # m, 	major radius 
a 		= 0.125 	# m, 	minor radius
n0 		= 1e18  	# m^-3, plasma density
Te0 	= 10 		# eV, 	electron temperature
B0 		= 0.1 		# T, 	magnetic field on axis

e 		= 1.60e-19 	# C
mp		= 1.67e-27 	# kg
N_nuclei       = 2         # Atom number (number of nuclei)

oci 		= e*B0/(N_nuclei*mp) 		    # ion gyrofrequency
rho_s 		= sqrt(2*e*Te0/(N_nuclei*mp))/oci   	# cold-ion hybrid thermal gyro-radius XXXXXXXXXXXXXXXXXXXXXXXXX

kappa 		= rho_s/R 	    # Effective gravity.
Dvort 		= 1e-2	    	# Vorticity diffusion
Dn 		    = 1e-2 	    	# Density diffusion
DT          = 1e-3          # Temperature diffusion
tau_source	= 1e3
tau_sink	= 1e4

bracket 	= 2 		# 0 = std, 1 = simple, 2 = arakawa

[All]
scale 		= 1.
bndry_all 	= neumann_o2

sigma_z 	= (0.05/2)/north:R
sigma_x 	= 0.1*sigma_z

[n]
scale       	= 7
function 	= 1. + 0.1*mixmode(2*pi*x) * mixmode(z)

[T]
scale       	= 1
function 	= 1. + 0.1*mixmode(2*pi*x) * mixmode(z)

[vort]
scale          	= 0.01
function 	= mixmode(2*pi*x) * mixmode(z) 

[source_n]
scale       	= 1
function 	= 1/(2*pi*all:sigma_x*all:sigma_z)*exp(-(x-(north:a + 7.1e-3)/north:R)^2/(2*all:sigma_x^2))*exp(-(z/(2*pi)-0.5)^2/(2*all:sigma_z^2))

[source_T]
scale       	= 0.1
function 	= 1/(2*pi*all:sigma_x*all:sigma_z)*exp(-(x-(north:a + 7.1e-3)/north:R)^2/(2*all:sigma_x^2))*exp(-(z/(2*pi)-0.5)^2/(2*all:sigma_z^2))



[fast_output]
type = monitor
frequency_multiplier = 100
flush = false 

xpos0 = 0.80
ypos0 = 0.00
zpos0 = 0.50

xpos1 = 0.82
ypos1 = 0.00
zpos1 = 0.50

xpos2 = 0.84
ypos2 = 0.00
zpos2 = 0.50